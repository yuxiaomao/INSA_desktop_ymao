:- include('tp1.pl').


%% test expand
test_expand(1) :-
    write("test element avec G init =10, etat N = "),
    initial_state(N,U),
    expand(U, [_, _, 10], S, [Fs, Hs, Gs], A),
    writeln(N),
    write_state(U),
    write("Fs="),writeln(Fs),
    write("Hs="),writeln(Hs),
    write("Gs="),writeln(Gs),
    writeln(A),
    write_state(S).

%% test loop successors
test_loop(1) :-
    % preparation of Q, Pu, Pf
    % deja explore 2 etat, reste 3 dans P
    Q0 = nil,
    Pu0 = nil,
    Pf0 = nil,
    U0 = [ [a, b, c],
          [g, h, d],
          [vide,f,e] ],
    insert([U0,[2,2,0],nil,nil], Q0, Q1),
    Element0 = [U0,[2,2,0],nil,nil],
    U1 = [ [a, b, c],
          [vide, h, d],
          [g,f,e] ],
    insert([U1,[2,1,1],U0,up], Q1, Q2),
    Element1 = [U1,[2,1,1],U0,up],
    U2 = [ [a, b, c],
          [g, h, d],
          [f,vide,e] ],
    Element2 = [U2,[4,3,1],U0,right],
    insert([U2,[4,3,1],U0,right], Pu0, Pu3),
    insert([[4,3,1],U2], Pf0, Pf3),
    U3 = [ [vide, b, c],
          [a, h, d],
          [g,f,e] ],
    Element3 = [U3,[4,2,2],U1,up],
    insert([U3,[4,2,2],U1,up], Pu3, Pu4),
    insert([[4,2,2],U3], Pf3, Pf4),
    U4 = [ [a, b, c],
          [h,vide, d],
          [g,f,e] ],
    Element4 = [U4,[2,0,2],U1,right],
    insert([U4,[2,0,2],U1,right], Pu4, Pu5),
    insert([[2,0,2],U4], Pf4, Pf5),
    U5 = [ [a, b, c],
          [g, h, d],
          [vide,f,e] ],
    Element5 = [U5,[4,2,2],U1,down],
    % ne s'ajoute pas dans Pu car U5=U2 deja dans Pu
    U6 = [ [b, vide, c],
          [a, h, d],
          [g,f,e] ],
    Element6 = [U6,[6,3,3],U3,right],

    % test
    write("cas 1, pas de successeur: ne doit rien faire"),
    loop_successors([],Pft1,Put1,_,Pft1,Put1),
    writeln("---OK"),
    write("cas 2, le premier element connu dans Q: ne doit rien faire"),
    loop_successors([Element0],Pft2,Put2,Q1,Pft2,Put2),
    loop_successors([Element1],Pft3,Put3,Q2,Pft3,Put3),
    writeln("---OK"),
    write("cas 3, le premier element connu dans P avec une moins bonne eval: ne doit rien faire"),
    loop_successors([[U2,[5,3,2],U0,right]],Pf5,Pu5,Q2,Pf5,Pu5),
    loop_successors([Element5],Pf5,Pu5,Q2,Pf5,Pu5),
    writeln("---OK"),
    write("cas 4, le premier element connu dans P avec une meilleure eval: modifie Pu et Pf"),
    loop_successors([[U3,[3,2,1],U1,foo]],Pf5,Pu5,Q2,Pft4,Put4),
    not(belongs(Element3,Put4)),
    not(belongs([[4,2,2],U3],Pft4)),
    belongs([U3,[3,2,1],U1,foo],Put4),
    belongs([[3,2,1],U3],Pft4),
    writeln("---OK"),
    write("cas 5, le premier element inconnu dans P ni Q: ajouter dans Pu et Pf"),
    not(belongs(Element6,Pu5)),
    not(belongs([[6,3,3],U6],Pf5)),
    loop_successors([Element6],Pf5,Pu5,Q2,Pft5,Put5),
    belongs(Element6,Put5),
    belongs([[6,3,3],U6],Pft5),
    writeln("---OK"),
    write("cas 6, une liste de (2) element"),
    loop_successors([Element5,Element6],Pf5,Pu5,Q2,Pft6,Put6),
    belongs(Element6,Put6),
    belongs([[6,3,3],U6],Pft6),
    not(belongs(Element5,Put6)),
    writeln("---OK").


%% test affiche solution
test_affiche_solution(1):-
    % preparation of Q, Pu, Pf
    % deja explore 2 etat, reste 3 dans P
    Q0 = nil,
    Pu0 = nil,
    Pf0 = nil,
    U0 = [ [a, b, c],
          [g, h, d],
          [vide,f,e] ],
    insert([U0,[2,2,0],nil,nil], Q0, Q1),
    Element0 = [U0,[2,2,0],nil,nil],
    U1 = [ [a, b, c],
          [vide, h, d],
          [g,f,e] ],
    insert([U1,[2,1,1],U0,up], Q1, Q2),
    Element1 = [U1,[2,1,1],U0,up],
    U2 = [ [a, b, c],
          [g, h, d],
          [f,vide,e] ],
    Element2 = [U2,[4,3,1],U0,right],
    insert([U2,[4,3,1],U0,right], Pu0, Pu3),
    insert([[4,3,1],U2], Pf0, Pf3),
    U3 = [ [vide, b, c],
          [a, h, d],
          [g,f,e] ],
    Element3 = [U3,[4,2,2],U1,up],
    insert([U3,[4,2,2],U1,up], Pu3, Pu4),
    insert([[4,2,2],U3], Pf3, Pf4),
    U4 = [ [a, b, c],
          [h,vide, d],
          [g,f,e] ],
    Element4 = [U4,[2,0,2],U1,right],
    insert([U4,[2,0,2],U1,right], Pu4, Pu5),
    insert([[2,0,2],U4], Pf4, Pf5),
    writeln("cas 1, solution a partir de nil"),
    writeln("Solution attendu: /*vide*/"),
    write("Solution obtenu: "),
    affiche_solution(nil,Pu5,Q2),nl,
    writeln("cas 2, solution a partir de pere"),
    writeln("Solution attendu: nil -> "),
    write("Solution obtenu: "),
    affiche_solution(U0,Pu5,Q2),nl,
    writeln("cas 3, solution 1 pas"),
    writeln("Solution attendu: nil -> up -> "),
    write("Solution obtenu: "),
    affiche_solution(U1,Pu5,Q2),nl,
    writeln("cas 4, solution 2 pas"),
    writeln("Solution attendu: nil -> up -> right -> "),
    write("Solution obtenu: "),
    affiche_solution(U4,Pu5,Q2),nl.
